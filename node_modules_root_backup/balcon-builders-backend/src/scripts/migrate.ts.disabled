import { Umzug, SequelizeStorage } from 'umzug';
import { sequelize } from '../config/database';
import path from 'path';

interface MigrationContext {
  name: string;
  path: string;
}

interface Migration {
  name: string;
}

const umzug = new Umzug({
  migrations: {
    glob: path.join(__dirname, '../migrations/*.ts'),
    resolve: ({ name, path: migrationPath }: MigrationContext) => {
      const migration = require(migrationPath);
      return {
        name,
        up: () => migration.up(sequelize.getQueryInterface()),
        down: () => migration.down(sequelize.getQueryInterface()),
      };
    },
  },
  context: sequelize.getQueryInterface(),
  storage: new SequelizeStorage({ sequelize }),
  logger: console,
});

export async function runMigrations(): Promise<void> {
  try {
    console.log('Starting database migrations...');
    const migrations = await umzug.up();
    
    if (migrations.length === 0) {
      console.log('No migrations to run');
    } else {
      console.log(`Successfully executed ${migrations.length} migrations:`);
      migrations.forEach((migration: Migration) => {
        console.log(`  ✓ ${migration.name}`);
      });
    }
  } catch (error) {
    console.error('Migration failed:', error);
    throw error;
  }
}

export async function rollbackMigrations(count: number = 1): Promise<void> {
  try {
    console.log(`Rolling back ${count} migration(s)...`);
    const migrations = await umzug.down({ count });
    
    console.log(`Successfully rolled back ${migrations.length} migrations:`);
    migrations.forEach((migration: Migration) => {
      console.log(`  ✓ ${migration.name}`);
    });
  } catch (error) {
    console.error('Rollback failed:', error);
    throw error;
  }
}

export async function getMigrationStatus(): Promise<void> {
  try {
    const pending = await umzug.pending();
    const executed = await umzug.executed();
    
    console.log('\nMigration Status:');
    console.log('================');
    
    if (executed.length > 0) {
      console.log('\nExecuted migrations:');
      executed.forEach((migration: Migration) => {
        console.log(`  ✓ ${migration.name}`);
      });
    }
    
    if (pending.length > 0) {
      console.log('\nPending migrations:');
      pending.forEach((migration: Migration) => {
        console.log(`  - ${migration.name}`);
      });
    } else {
      console.log('\nAll migrations are up to date!');
    }
  } catch (error) {
    console.error('Failed to get migration status:', error);
    throw error;
  }
}

// CLI interface
if (require.main === module) {
  const command = process.argv[2];
  
  switch (command) {
    case 'up':
      runMigrations().catch(process.exit);
      break;
    case 'down':
      const count = parseInt(process.argv[3]) || 1;
      rollbackMigrations(count).catch(process.exit);
      break;
    case 'status':
      getMigrationStatus().catch(process.exit);
      break;
    default:
      console.log('Usage:');
      console.log('  npm run migrate up     - Run all pending migrations');
      console.log('  npm run migrate down   - Rollback last migration');
      console.log('  npm run migrate down 2 - Rollback last 2 migrations');
      console.log('  npm run migrate status - Show migration status');
      process.exit(1);
  }
}
